// ===================================================================================================
// üåê SERVIDOR DE AUTENTICACI√ìN JWT - BACKEND COMPLETO
// ===================================================================================================

// ===================================================================================================
// üì¶ IMPORTACIONES Y DEPENDENCIAS PRINCIPALES
// ===================================================================================================

// ============================================================================
// üìà INTEGRACI√ìN CON DATADOG (MONITOREO)
// ============================================================================

// Importar el tracer de Datadog para habilitar monitoreo APM
// La inicializaci√≥n debe ocurrir antes de cargar Express para instrumentarlo
import tracer from 'dd-trace';

if (process.env.DATADOG_ENABLED === 'true') {
  tracer.init({
    service: process.env.DATADOG_SERVICE || 'jwt-example-backend',
    env: process.env.DATADOG_ENV || 'development',
    logInjection: true
  });
  tracer.use('express');
  console.log('üìà Datadog tracing habilitado');
}

// Framework Express.js para crear el servidor HTTP y manejar rutas REST
// Express es el framework web m√°s popular para Node.js, proporciona routing, middleware y manejo de HTTP
import express from 'express';

// Librer√≠a jsonwebtoken - est√°ndar de facto para JWT en Node.js
// Proporciona funciones para crear (sign), verificar (verify) y decodificar (decode) tokens JWT
// Soporta m√∫ltiples algoritmos: HS256, RS256, ES256, etc.
import jwt from 'jsonwebtoken';

// Middleware CORS (Cross-Origin Resource Sharing) para permitir peticiones desde diferentes dominios
// Esencial para permitir que el frontend (puerto 5173) se comunique con el backend (puerto 3000)
// Configura headers HTTP necesarios para superar las pol√≠ticas de mismo origen del navegador
import cors from 'cors';

// ===================================================================================================
// üîß CONFIGURACI√ìN B√ÅSICA DEL SERVIDOR
// ===================================================================================================

// Crear la instancia principal de la aplicaci√≥n Express
// Esta instancia ser√° el n√∫cleo de nuestro servidor HTTP y manejar√° todas las rutas y middleware
const app = express();

// Puerto donde el servidor escuchar√° las conexiones HTTP
// En producci√≥n esto deber√≠a venir de process.env.PORT para flexibilidad de despliegue
const PORT = process.env.PORT || 3000;

// ===================================================================================================
// üîë CONFIGURACI√ìN DE SEGURIDAD JWT
// ===================================================================================================

// SECRETOS JWT PARA FIRMADO DIGITAL DE TOKENS
// CR√çTICO: Estos secretos se obtienen de variables de entorno para m√°xima seguridad
// Los secretos deben ser strings aleatorios de al menos 256 bits (32 caracteres)
// En desarrollo se proporcionan valores por defecto para facilitar el setup

// Clave secreta para firmar y verificar ACCESS TOKENS
// Se usa con el algoritmo HMAC SHA-256 (HS256) para crear la firma digital
// Esta clave debe ser altamente secreta y rotarse peri√≥dicamente en producci√≥n
const JWT_SECRET = process.env.JWT_SECRET || 'development-jwt-secret-change-in-production';

// Clave separada para REFRESH TOKENS - implementa estrategia de doble-clave
// Usar claves separadas aumenta la seguridad: si una se compromete, la otra sigue siendo v√°lida
// Permite invalidar solo un tipo de token sin afectar al otro
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'development-refresh-secret-change-in-production';

// ===================================================================================================
// ‚öôÔ∏è CONFIGURACI√ìN DE MIDDLEWARE DE EXPRESS
// ===================================================================================================

// Configurar middleware CORS para permitir comunicaci√≥n cross-origin
// CORS es necesario porque el frontend (localhost:5173) y backend (localhost:3000) son diferentes or√≠genes
app.use(cors({
  origin: process.env.CORS_ORIGIN || 'http://localhost:5173', // Dominio espec√≠fico del frontend - m√°s seguro que '*'
  credentials: true                // Permite env√≠o de cookies y headers de autenticaci√≥n
  // En producci√≥n: usar array de or√≠genes permitidos y configurar seg√∫n el ambiente
}));

// Middleware para parsear autom√°ticamente cuerpos JSON en las peticiones HTTP
// Convierte el JSON del body de las peticiones en objetos JavaScript accesibles via req.body
// Equivale a usar body-parser.json() en versiones anteriores de Express
app.use(express.json());

// ===================================================================================================
// üë• SIMULACI√ìN DE BASE DE DATOS DE USUARIOS
// ===================================================================================================

// Lista simulada de usuarios para demostraci√≥n del sistema JWT
// IMPORTANTE: En producci√≥n esto debe ser una base de datos real (PostgreSQL, MongoDB, etc.)
// Las contrase√±as deben estar hasheadas con bcrypt, Argon2 u otro algoritmo seguro
// NOTA: Estos son usuarios de ejemplo para demostraci√≥n - cambiar en producci√≥n
const users = [
  { id: '1', username: 'quemasandy', password: '123123', role: 'user' },
  { id: '2', username: 'demo_admin', password: 'admin456', role: 'admin' },
  { id: '3', username: 'demo_super', password: 'super789', role: 'superadmin' },
  { id: '4', username: 'test_user', password: 'test123', role: 'user' }
];

// ===================================================================================================
// üóÑÔ∏è ALMACENAMIENTO TEMPORAL DE REFRESH TOKENS
// ===================================================================================================

// Array en memoria para almacenar refresh tokens v√°lidos
// CR√çTICO: En producci√≥n usar Redis, base de datos o almacenamiento distribuido
// Este enfoque permite:
// 1. Invalidaci√≥n inmediata de tokens (logout)
// 2. Revocaci√≥n de tokens comprometidos
// 3. L√≠mite de tokens activos por usuario
// 4. Auditor√≠a de tokens emitidos
const refreshTokens: string[] = [];

// ===================================================================================================
// üè∑Ô∏è DEFINICIONES DE TIPOS TYPESCRIPT PARA JWT
// ===================================================================================================

// Interfaz para el payload del ACCESS TOKEN
// Define la estructura exacta de datos que se almacenan dentro del JWT
// Estos datos est√°n VISIBLES (solo codificados en base64) pero FIRMADOS digitalmente
interface JwtPayload {
  userId: string;   // Identificador √∫nico del usuario - llave primaria de BD
  username: string; // Nombre de usuario - √∫til para logging y UI
  role: string;     // Rol de autorizaci√≥n - determina permisos y acceso a recursos
  iat?: number;     // "Issued At" - timestamp de emisi√≥n (a√±adido autom√°ticamente por jwt.sign)
  exp?: number;     // "Expires" - timestamp de expiraci√≥n (calculado desde expiresIn)
}

// Interfaz para el payload del REFRESH TOKEN
// Contiene datos m√≠nimos necesarios para renovar access tokens
// Menos informaci√≥n = menor superficie de ataque si se compromete
interface RefreshTokenPayload {
  userId: string;      // Usuario propietario del token - para buscar en BD
  tokenVersion: number; // Versi√≥n del token - permite invalidar versiones antiguas
  iat?: number;        // Timestamp de emisi√≥n
  exp?: number;        // Timestamp de expiraci√≥n (7 d√≠as)
}

// ===================================================================================================
// üîê FUNCI√ìN PARA CREAR ACCESS TOKENS
// ===================================================================================================

// Genera un access token JWT de corta duraci√≥n para un usuario autenticado
// Los access tokens contienen informaci√≥n del usuario y tienen vida corta (15 min)
// para minimizar el impacto si son comprometidos
function createAccessToken(user: typeof users[0]): string {
  console.log('üîê =================================================');
  console.log('üçª INICIANDO CREACI√ìN DE ACCESS TOKEN');
  console.log('üîê =================================================');
  
  // Construir el payload con informaci√≥n esencial del usuario
  // IMPORTANTE: No incluir informaci√≥n sensible como contrase√±as
  const payload: JwtPayload = {
    userId: user.id,           // ID para consultas de BD
    username: user.username,   // Nombre para mostrar en UI
    role: user.role           // Rol para control de acceso
  };

  // Log detallado para debugging y auditor√≠a
  console.log('üìã Payload a firmar:');
  console.log('   ‚Ä¢ User ID:', payload.userId);
  console.log('   ‚Ä¢ Username:', payload.username);
  console.log('   ‚Ä¢ Role:', payload.role);
  console.log('   ‚Ä¢ Algoritmo de firma: HS256 (HMAC SHA-256)');
  
  // Firmar digitalmente el payload usando la clave secreta
  // jwt.sign() hace tres cosas:
  // 1. Codifica header y payload en base64url
  // 2. Crea firma HMAC del header.payload usando la clave secreta
  // 3. Concatena: header.payload.signature
  const token = jwt.sign(payload, JWT_SECRET, {
    expiresIn: '15m' // Token de vida corta - balance entre seguridad y UX
  });
  
  // Informaci√≥n de depuraci√≥n y confirmaci√≥n
  console.log('‚úÖ TOKEN FIRMADO EXITOSAMENTE:');
  console.log('   üîç Longitud total:', token.length, 'caracteres');
  console.log('   üîç Preview:', token.substring(0, 50) + '...');
  console.log('   ‚è∞ Duraci√≥n: 15 minutos');
  console.log('   üõ°Ô∏è Algoritmo: HS256');
  console.log('   üìÖ Creado:', new Date().toISOString());
  
  return token;
}

// ===================================================================================================
// üîÑ FUNCI√ìN PARA CREAR REFRESH TOKENS
// ===================================================================================================

// Genera un refresh token JWT de larga duraci√≥n para renovaci√≥n de access tokens
// Los refresh tokens tienen vida larga (7 d√≠as) pero contienen menos informaci√≥n
// Se almacenan en el servidor para permitir revocaci√≥n inmediata
function createRefreshToken(userId: string): string {
  console.log('üîÑ =================================================');
  console.log('üîÑ INICIANDO CREACI√ìN DE REFRESH TOKEN');
  console.log('üîÑ =================================================');
  
  // Payload minimalista para refresh token
  // Solo informaci√≥n esencial para renovar el access token
  const payload: RefreshTokenPayload = {
    userId,                  // Usuario propietario
    tokenVersion: 1         // Versi√≥n para invalidaci√≥n masiva
  };

  console.log('üìã Payload del refresh token:');
  console.log('   ‚Ä¢ User ID:', payload.userId);
  console.log('   ‚Ä¢ Token Version:', payload.tokenVersion);
  console.log('   ‚Ä¢ Prop√≥sito: Renovaci√≥n de access tokens');
  
  // Firmar con clave separada para mayor seguridad
  // Usar clave diferente permite rotaci√≥n independiente y mejor aislamiento
  const token = jwt.sign(payload, JWT_REFRESH_SECRET, {
    expiresIn: '7d' // Vida larga para mejor UX - el usuario no necesita login frecuente
  });
  
  console.log('‚úÖ REFRESH TOKEN CREADO:');
  console.log('   üîç Longitud:', token.length, 'caracteres');
  console.log('   ‚è∞ Duraci√≥n: 7 d√≠as');
  console.log('   üõ°Ô∏è Algoritmo: HS256 (clave separada)');
  console.log('   üìÖ Creado:', new Date().toISOString());
  
  // CR√çTICO: Almacenar en lista de tokens v√°lidos para control de revocaci√≥n
  // Esto permite logout efectivo y revocaci√≥n de tokens comprometidos
  refreshTokens.push(token);
  console.log('üíæ Token agregado a lista v√°lida (total activos:', refreshTokens.length, ')');
  
  return token;
}

// ===================================================================================================
// üîí MIDDLEWARE DE AUTENTICACI√ìN JWT
// ===================================================================================================

// Middleware que intercepta peticiones para verificar access tokens JWT
// Se ejecuta ANTES de las rutas protegidas para validar autorizaci√≥n
// Implementa el patr√≥n de autenticaci√≥n Bearer Token est√°ndar
const authenticateToken = (
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) => {
  console.log('\nüîí ================================================');
  console.log('üîç INICIANDO VERIFICACI√ìN DE ACCESS TOKEN');
  console.log('üîí ================================================');
  
  // PASO 1: Extraer token del header Authorization
  // El cliente debe enviar: Authorization: Bearer <jwt-token>
  const authHeader = req.headers['authorization'];
  
  console.log('üì• Analizando headers de autorizaci√≥n:');
  console.log('   ‚Ä¢ Authorization header presente:', !!authHeader);
  console.log('   ‚Ä¢ Valor completo:', authHeader || 'No presente');
  
  // Extraer solo el token (remover "Bearer " del inicio)
  // authHeader formato esperado: "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  const token = authHeader && authHeader.split(' ')[1];
  
  console.log('üé´ Resultado de extracci√≥n:');
  console.log('   ‚Ä¢ Token extra√≠do:', !!token);
  if (token) {
    console.log('   ‚Ä¢ Longitud del token:', token.length);
    console.log('   ‚Ä¢ Preview:', token.substring(0, 30) + '...');
  }

  // PASO 2: Validar presencia del token
  if (!token) {
    console.log('‚ùå FALLO DE AUTENTICACI√ìN: Token no proporcionado');
    console.log('   ‚Ä¢ Causa: Header Authorization ausente o malformado');
    console.log('   ‚Ä¢ Formato esperado: "Authorization: Bearer <token>"');
    console.log('   ‚Ä¢ Respondiendo con status 401 Unauthorized');
    
    return res.status(401).json({
      error: 'Access token requerido',
      hint: 'Incluye header: Authorization: Bearer <token>',
      documentation: 'Consulta la documentaci√≥n de autenticaci√≥n JWT'
    });
  }

  // PASO 3: Verificar y decodificar el token
  try {
    console.log('üîì Verificando token con clave secreta...');
    console.log('   ‚Ä¢ Algoritmo esperado: HS256');
    console.log('   ‚Ä¢ Verificando firma digital...');
    
    // jwt.verify() hace tres validaciones cr√≠ticas:
    // 1. Decodifica y valida estructura del JWT
    // 2. Verifica firma usando la clave secreta
    // 3. Valida timestamps (nbf, exp, iat)
    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;
    
    console.log('‚úÖ TOKEN VERIFICADO EXITOSAMENTE:');
    console.log('   üë§ Usuario:', decoded.username);
    console.log('   üÜî User ID:', decoded.userId);
    console.log('   üé≠ Rol:', decoded.role);
    console.log('   üìÖ Emitido:', new Date(decoded.iat! * 1000).toLocaleString());
    console.log('   ‚è∞ Expira:', new Date(decoded.exp! * 1000).toLocaleString());
    
    // Calcular tiempo restante
    const now = Math.floor(Date.now() / 1000);
    const timeLeft = decoded.exp! - now;
    console.log('   ‚è±Ô∏è Tiempo restante:', timeLeft > 0 ? `${timeLeft} segundos` : 'EXPIRADO');
    
    // PASO 4: Adjuntar informaci√≥n del usuario al request
    // Esto permite a las rutas posteriores acceder a los datos del usuario autenticado
    (req as any).user = decoded;
    
    console.log('üöÄ Continuando a la ruta protegida...');
    next(); // Pasar control al siguiente middleware/ruta
    
  } catch (error) {
    // MANEJO DETALLADO DE ERRORES JWT
    console.log('‚ùå ERROR DE VERIFICACI√ìN JWT:');
    
    if (error instanceof jwt.TokenExpiredError) {
      // Token v√°lido pero expirado - el cliente debe renovarlo
      console.log('‚è∞ TIPO: Token expirado');
      console.log('   ‚Ä¢ Fecha de expiraci√≥n:', error.expiredAt);
      console.log('   ‚Ä¢ Tiempo transcurrido desde expiraci√≥n:', 
                  Math.floor(Date.now() / 1000) - Math.floor(error.expiredAt.getTime() / 1000), 'segundos');
      console.log('   ‚Ä¢ Acci√≥n requerida: Cliente debe usar refresh token');
      
      return res.status(401).json({
        error: 'Token expirado',
        expiredAt: error.expiredAt,
        hint: 'Usa el refresh token para obtener uno nuevo',
        action: 'refresh_token'
      });
      
    } else if (error instanceof jwt.JsonWebTokenError) {
      // Token malformado, firma inv√°lida, o algoritmo incorrecto
      console.log('üîç TIPO: Token inv√°lido');
      console.log('   ‚Ä¢ Detalle del error:', error.message);
      console.log('   ‚Ä¢ Posibles causas:');
      console.log('     - Firma digital inv√°lida (token manipulado)');
      console.log('     - Algoritmo incorrecto');
      console.log('     - Token malformado o corrupto');
      console.log('     - Clave secreta incorrecta');
      
      return res.status(403).json({
        error: 'Token inv√°lido',
        details: error.message,
        hint: 'Obt√©n un nuevo token a trav√©s del login'
      });
      
    } else {
      // Error inesperado del sistema
      console.log('üí• TIPO: Error inesperado del sistema');
      console.log('   ‚Ä¢ Error:', error);
      console.log('   ‚Ä¢ Acci√≥n: Revisar configuraci√≥n del servidor');
      
      return res.status(500).json({ 
        error: 'Error interno verificando token',
        hint: 'Contacta al administrador del sistema'
      });
    }
  }
};

// ===================================================================================================
// üåê DEFINICI√ìN DE RUTAS DE LA API
// ===================================================================================================

console.log('üö™ Configurando rutas de la API...');

// ===================================================================================================
// üîê RUTA: POST /api/login - Autenticaci√≥n de usuarios
// ===================================================================================================

// Endpoint para autenticar usuarios y generar tokens JWT iniciales
// Esta es la puerta de entrada al sistema - genera ambos tokens (access + refresh)
app.post('/api/login', (req, res) => {
  console.log('\nüîê ================================================');
  console.log('üîê NUEVA SOLICITUD DE LOGIN JWT');
  console.log('üîê ================================================');
  
  // Extraer credenciales del cuerpo de la petici√≥n
  const { username, password } = req.body;
  
  console.log('üì• Credenciales recibidas:');
  console.log('   ‚Ä¢ Username:', username || 'No proporcionado');
  console.log('   ‚Ä¢ Password:', password ? '[PRESENTE]' : 'No proporcionado');
  console.log('   ‚Ä¢ IP cliente:', req.ip);
  console.log('   ‚Ä¢ User-Agent:', req.get('User-Agent')?.substring(0, 50) + '...');
  
  // VALIDACI√ìN B√ÅSICA DE ENTRADA
  if (!username || !password) {
    console.log('‚ùå VALIDACI√ìN FALL√ì: Credenciales incompletas');
    return res.status(400).json({
      success: false,
      error: 'Username y password son requeridos',
      hint: 'Env√≠a ambos campos en el body de la petici√≥n'
    });
  }
  
  console.log('üîç Buscando usuario en base de datos simulada...');
  
  // B√öSQUEDA Y VERIFICACI√ìN DE CREDENCIALES
  // En producci√≥n: usar bcrypt.compare() para verificar password hasheado
  const user = users.find(u => u.username === username && u.password === password);
  
  if (user) {
    // ‚úÖ CREDENCIALES V√ÅLIDAS - GENERAR TOKENS
    console.log('‚úÖ AUTENTICACI√ìN EXITOSA:');
    console.log('   üë§ Usuario encontrado:');
    console.log('     - ID:', user.id);
    console.log('     - Username:', user.username);
    console.log('     - Rol:', user.role);
    console.log('   üé´ Generando tokens JWT...');
    
    // Crear ambos tokens para implementar estrategia de doble token
    const accessToken = createAccessToken(user);
    const refreshToken = createRefreshToken(user.id);
    
    console.log('\nüì§ PREPARANDO RESPUESTA DE LOGIN EXITOSO:');
    console.log('   ‚Ä¢ Access token generado: ‚úÖ');
    console.log('   ‚Ä¢ Refresh token generado: ‚úÖ');
    console.log('   ‚Ä¢ Tokens almacenados en servidor: ‚úÖ');
    console.log('   ‚Ä¢ Enviando al cliente...');
    
    // Respuesta estructurada con toda la informaci√≥n necesaria
    res.json({
      success: true,
      message: 'Login exitoso - Bienvenido al sistema',
      user: { 
        id: user.id, 
        username: user.username, 
        role: user.role 
      },
      accessToken,                    // Token para peticiones API (15 min)
      refreshToken,                   // Token para renovaci√≥n (7 d√≠as)
      tokenType: 'Bearer',           // Tipo est√°ndar para JWT
      expiresIn: 900,                // 15 minutos en segundos
      note: 'üí° Guarda ambos tokens para futuras peticiones',
      security: {
        algorithm: 'HS256',
        accessTokenDuration: '15 minutes',
        refreshTokenDuration: '7 days'
      }
    });
    
  } else {
    // ‚ùå CREDENCIALES INV√ÅLIDAS
    console.log('‚ùå AUTENTICACI√ìN FALL√ì:');
    console.log('   ‚Ä¢ Usuario no encontrado o contrase√±a incorrecta');
    console.log('   ‚Ä¢ Username intentado:', username);
    console.log('   ‚Ä¢ Motivos posibles:');
    console.log('     - Usuario no existe');
    console.log('     - Contrase√±a incorrecta');
    console.log('     - Cuenta deshabilitada');
    console.log('   ‚ö†Ô∏è Respondiendo con error gen√©rico por seguridad');
    
    // Respuesta gen√©rica para no revelar si el usuario existe
    res.status(401).json({
      success: false,
      message: 'Credenciales incorrectas',
      hint: 'Verifica tu usuario y contrase√±a',
      security: 'Por seguridad, no se especifica qu√© credencial es incorrecta'
    });
  }
});

// ===================================================================================================
// üë§ RUTA: GET /api/profile - Perfil de usuario autenticado
// ===================================================================================================

// Ruta protegida que devuelve informaci√≥n del usuario autenticado
// Demuestra c√≥mo extraer datos directamente del JWT sin consultar la base de datos
app.get('/api/profile', authenticateToken, (req, res) => {
  console.log('\nüë§ ================================================');
  console.log('üë§ SOLICITUD DE PERFIL DE USUARIO');
  console.log('üë§ ================================================');
  
  // El middleware authenticateToken ya valid√≥ el token y agreg√≥ user al request
  const user = (req as any).user as JwtPayload;
  
  console.log('üìã Informaci√≥n extra√≠da del JWT:');
  console.log('   üë§ Usuario:', user.username);
  console.log('   üÜî ID:', user.userId);
  console.log('   üé≠ Rol:', user.role);
  console.log('   üìÖ Token emitido:', new Date(user.iat! * 1000).toLocaleString());
  console.log('   ‚è∞ Token expira:', new Date(user.exp! * 1000).toLocaleString());
  
  // Calcular informaci√≥n adicional del token
  const now = Math.floor(Date.now() / 1000);
  const timeLeft = user.exp! - now;
  
  console.log('‚è±Ô∏è Estado del token:');
  console.log('   ‚Ä¢ Tiempo restante:', timeLeft, 'segundos');
  console.log('   ‚Ä¢ Estado:', timeLeft > 0 ? 'V√ÅLIDO' : 'EXPIRADO');
  console.log('   ‚Ä¢ Porcentaje de vida restante:', Math.round((timeLeft / 900) * 100), '%');
  
  // Respuesta con informaci√≥n completa del perfil y metadata del token
  res.json({
    success: true,
    message: 'Perfil obtenido exitosamente',
    user: {
      id: user.userId,
      username: user.username,
      role: user.role
    },
    tokenInfo: {
      issuedAt: new Date(user.iat! * 1000).toISOString(),
      expiresAt: new Date(user.exp! * 1000).toISOString(),
      timeLeft: timeLeft + ' segundos',
      percentageLeft: Math.round((timeLeft / 900) * 100) + '%'
    },
    note: 'üçª Datos extra√≠dos directamente del JWT - Sin consulta a BD',
    advantages: [
      'Sin latencia de base de datos',
      'Escalabilidad horizontal',
      'Stateless server architecture'
    ]
  });
});

// ===================================================================================================
// üîí RUTA: GET /api/secret-data - Datos protegidos basados en roles
// ===================================================================================================

// Ruta que demuestra autorizaci√≥n basada en roles usando informaci√≥n del JWT
// Diferentes usuarios obtienen diferentes datos seg√∫n su rol
app.get('/api/secret-data', authenticateToken, (req, res) => {
  console.log('\nüîí ================================================');
  console.log('üîí ACCESO A DATOS SECRETOS (RBAC)');
  console.log('üîí ================================================');
  
  const user = (req as any).user as JwtPayload;
  
  console.log('üé≠ An√°lisis de autorizaci√≥n basada en roles:');
  console.log('   üë§ Usuario:', user.username);
  console.log('   üè∑Ô∏è Rol actual:', user.role);
  console.log('   üîç Determinando nivel de acceso...');
  
  // IMPLEMENTACI√ìN DE RBAC (Role-Based Access Control)
  let secretData: string;
  let accessLevel: string;
  let permissions: string[];
  
  switch (user.role) {
    case 'superadmin':
      secretData = 'üëë Datos ultra secretos del super administrador';
      accessLevel = 'M√ÅXIMO';
      permissions = ['read', 'write', 'delete', 'admin', 'system'];
      console.log('   üîë Nivel SUPERADMIN detectado - Acceso total concedido');
      break;
      
    case 'admin':
      secretData = 'üîê Datos secretos del administrador';
      accessLevel = 'ALTO';
      permissions = ['read', 'write', 'delete', 'admin'];
      console.log('   üîë Nivel ADMIN detectado - Acceso administrativo concedido');
      break;
      
    default:
      secretData = 'üìä Datos b√°sicos del usuario';
      accessLevel = 'B√ÅSICO';
      permissions = ['read'];
      console.log('   üîë Nivel USER detectado - Acceso b√°sico concedido');
  }
  
  console.log('‚úÖ Autorizaci√≥n completada:');
  console.log('   üéØ Nivel de acceso:', accessLevel);
  console.log('   üõ°Ô∏è Permisos otorgados:', permissions.join(', '));
  console.log('   üì¶ Datos a retornar:', secretData.substring(0, 30) + '...');
  
  // Respuesta con datos personalizados seg√∫n el rol
  res.json({
    success: true,
    message: `Datos secretos para usuario ${user.username}`,
    secretData,
    authorization: {
      userRole: user.role,
      accessLevel,
      permissions,
      grantedAt: new Date().toISOString()
    },
    user: {
      username: user.username,
      role: user.role
    },
    note: 'üé≠ Contenido personalizado basado en RBAC desde JWT',
    timestamp: new Date().toISOString()
  });
});

// ===================================================================================================
// üîÑ RUTA: POST /api/refresh - Renovaci√≥n de access tokens
// ===================================================================================================

// Endpoint cr√≠tico para renovar access tokens usando refresh tokens v√°lidos
// Implementa el patr√≥n de renovaci√≥n autom√°tica para mejorar UX sin comprometer seguridad
app.post('/api/refresh', (req, res) => {
  console.log('\nüîÑ ================================================');
  console.log('üîÑ SOLICITUD DE RENOVACI√ìN DE ACCESS TOKEN');
  console.log('üîÑ ================================================');
  
  const { refreshToken } = req.body;
  
  console.log('üì• Analizando petici√≥n de refresh:');
  console.log('   ‚Ä¢ Refresh token recibido:', !!refreshToken);
  if (refreshToken) {
    console.log('   ‚Ä¢ Longitud del token:', refreshToken.length);
    console.log('   ‚Ä¢ Preview:', refreshToken.substring(0, 30) + '...');
  }
  
  // VALIDACI√ìN 1: Verificar presencia del refresh token
  if (!refreshToken) {
    console.log('‚ùå VALIDACI√ìN FALL√ì: Refresh token no proporcionado');
    return res.status(401).json({
      error: 'Refresh token requerido',
      hint: 'Env√≠a { "refreshToken": "tu-refresh-token" } en el body',
      format: 'application/json'
    });
  }
  
  // VALIDACI√ìN 2: Verificar que el token est√© en nuestra lista de tokens v√°lidos
  console.log('üîç Verificando token en lista de tokens v√°lidos...');
  console.log('   ‚Ä¢ Tokens activos en servidor:', refreshTokens.length);
  
  if (!refreshTokens.includes(refreshToken)) {
    console.log('‚ùå VALIDACI√ìN FALL√ì: Refresh token no encontrado en lista v√°lida');
    console.log('   ‚Ä¢ Posibles causas:');
    console.log('     - Token ya fue usado y revocado');
    console.log('     - Token fue invalidado por logout');
    console.log('     - Token no fue emitido por este servidor');
    console.log('     - Ataque con token robado');
    
    return res.status(403).json({
      error: 'Refresh token inv√°lido o revocado',
      hint: 'Realiza login para obtener nuevos tokens',
      security: 'Token no encontrado en lista de tokens v√°lidos'
    });
  }
  
  console.log('‚úÖ Token encontrado en lista v√°lida');
  
  // VALIDACI√ìN 3: Verificar firma y validez del refresh token
  try {
    console.log('üîì Verificando firma del refresh token...');
    console.log('   ‚Ä¢ Algoritmo: HS256');
    console.log('   ‚Ä¢ Clave: Refresh secret key');
    
    const decoded = jwt.verify(refreshToken, JWT_REFRESH_SECRET) as RefreshTokenPayload;
    
    console.log('‚úÖ REFRESH TOKEN VERIFICADO:');
    console.log('   üë§ User ID:', decoded.userId);
    console.log('   üî¢ Token version:', decoded.tokenVersion);
    console.log('   üìÖ Emitido:', new Date(decoded.iat! * 1000).toLocaleString());
    console.log('   ‚è∞ Expira:', new Date(decoded.exp! * 1000).toLocaleString());
    
    // PASO 4: Buscar usuario correspondiente
    console.log('üîç Buscando usuario en base de datos...');
    const user = users.find(u => u.id === decoded.userId);
    
    if (!user) {
      console.log('‚ùå ERROR: Usuario no encontrado');
      console.log('   ‚Ä¢ User ID buscado:', decoded.userId);
      console.log('   ‚Ä¢ Posibles causas:');
      console.log('     - Usuario fue eliminado');
      console.log('     - ID corrompido en token');
      console.log('     - Inconsistencia en base de datos');
      
      return res.status(404).json({ 
        error: 'Usuario no encontrado',
        hint: 'El usuario asociado al token no existe'
      });
    }
    
    console.log('‚úÖ Usuario encontrado:', user.username);
    
    // PASO 5: Generar nuevo access token
    console.log('üèóÔ∏è Generando nuevo access token...');
    const newAccessToken = createAccessToken(user);
    
    console.log('üçª RENOVACI√ìN COMPLETADA EXITOSAMENTE:');
    console.log('   ‚úÖ Nuevo access token generado');
    console.log('   ‚è∞ V√°lido por 15 minutos adicionales');
    console.log('   üîÑ Refresh token permanece v√°lido');
    console.log('   üì§ Enviando respuesta al cliente...');
    
    // Respuesta con nuevo access token
    res.json({
      success: true,
      message: 'Access token renovado exitosamente',
      accessToken: newAccessToken,
      tokenType: 'Bearer',
      expiresIn: 900,               // 15 minutos
      refreshInfo: {
        originalTokenStillValid: true,
        renewalsRemaining: 'Hasta que expire el refresh token',
        refreshTokenExpiresAt: new Date(decoded.exp! * 1000).toISOString()
      },
      note: 'üîÑ Token renovado autom√°ticamente - UX mejorada sin comprometer seguridad'
    });
    
  } catch (error) {
    // MANEJO DE ERRORES EN VERIFICACI√ìN DEL REFRESH TOKEN
    console.log('‚ùå ERROR VERIFICANDO REFRESH TOKEN:');
    
    if (error instanceof jwt.TokenExpiredError) {
      // Refresh token expirado - usuario debe hacer login completo
      console.log('‚è∞ TIPO: Refresh token expirado');
      console.log('   ‚Ä¢ Expir√≥ en:', error.expiredAt);
      console.log('   ‚Ä¢ Acci√≥n: Limpiar de lista v√°lida y requerir login');
      
      // Limpiar token expirado de la lista
      const index = refreshTokens.indexOf(refreshToken);
      if (index > -1) {
        refreshTokens.splice(index, 1);
        console.log('üóëÔ∏è Token expirado removido de lista v√°lida');
      }
      
      return res.status(401).json({ 
        error: 'Refresh token expirado',
        hint: 'Realiza login nuevamente para obtener nuevos tokens',
        action: 'login_required',
        expiredAt: error.expiredAt
      });
      
    } else {
      // Error gen√©rico de verificaci√≥n
      console.log('üí• TIPO: Error de verificaci√≥n gen√©rico');
      console.log('   ‚Ä¢ Detalle:', error);
      console.log('   ‚Ä¢ Acci√≥n: Considerar token comprometido');
      
      return res.status(403).json({ 
        error: 'Refresh token inv√°lido',
        hint: 'Token corrompido o manipulado - realiza login nuevamente'
      });
    }
  }
});

// ===================================================================================================
// üö™ RUTA: POST /api/logout - Cerrar sesi√≥n e invalidar tokens
// ===================================================================================================

// Endpoint para cerrar sesi√≥n de forma segura invalidando el refresh token
// Implementa logout server-side para prevenir reutilizaci√≥n de tokens
app.post('/api/logout', (req, res) => {
  console.log('\nüö™ ================================================');
  console.log('üö™ SOLICITUD DE LOGOUT - INVALIDACI√ìN DE SESI√ìN');
  console.log('üö™ ================================================');
  
  const { refreshToken } = req.body;
  
  console.log('üì• Analizando solicitud de logout:');
  console.log('   ‚Ä¢ Refresh token para invalidar:', !!refreshToken);
  console.log('   ‚Ä¢ IP cliente:', req.ip);
  console.log('   ‚Ä¢ Tokens activos antes del logout:', refreshTokens.length);
  
  if (refreshToken) {
    console.log('üîç Buscando refresh token en lista v√°lida...');
    
    // Buscar y remover el refresh token de la lista de tokens v√°lidos
    const index = refreshTokens.indexOf(refreshToken);
    
    if (index > -1) {
      // Token encontrado - proceder con invalidaci√≥n
      refreshTokens.splice(index, 1);
      console.log('‚úÖ INVALIDACI√ìN EXITOSA:');
      console.log('   üóëÔ∏è Refresh token removido de lista v√°lida');
      console.log('   üìä Tokens activos restantes:', refreshTokens.length);
      console.log('   üõ°Ô∏è Token ya no puede ser usado para renovaciones');
    } else {
      console.log('‚ö†Ô∏è ADVERTENCIA: Token no encontrado en lista');
      console.log('   ‚Ä¢ Posibles razones:');
      console.log('     - Token ya fue invalidado previamente');
      console.log('     - Token nunca fue v√°lido');
      console.log('     - M√∫ltiples intentos de logout');
      console.log('   ‚Ä¢ Acci√≥n: Proceder con logout de todas formas');
    }
  } else {
    console.log('‚ÑπÔ∏è INFO: Logout sin refresh token');
    console.log('   ‚Ä¢ Cliente puede estar limpiando sesi√≥n local √∫nicamente');
    console.log('   ‚Ä¢ No hay tokens del servidor para invalidar');
  }
  
  console.log('‚úÖ LOGOUT COMPLETADO:');
  console.log('   üîì Sesi√≥n del servidor invalidada');
  console.log('   üí≠ Access token seguir√° v√°lido hasta expiraci√≥n natural');
  console.log('   üö´ Nuevas renovaciones bloqueadas');
  console.log('   üì§ Confirmando logout al cliente...');
  
  // Confirmaci√≥n de logout exitoso
  res.json({
    success: true,
    message: 'Logout exitoso - Sesi√≥n cerrada',
    serverAction: 'Refresh token invalidado en servidor',
    clientAction: 'Limpiar tokens del almacenamiento local',
    security: {
      refreshTokenInvalidated: !!refreshToken,
      accessTokenNote: 'El access token permanece t√©cnicamente v√°lido hasta su expiraci√≥n natural (m√°x 15 min)',
      renewalBlocked: true
    },
    note: 'üí° Por seguridad completa, tambi√©n limpia los tokens del cliente',
    timestamp: new Date().toISOString()
  });
});

// ===================================================================================================
// üîç RUTA: POST /api/verify-token - Verificaci√≥n manual de tokens (Debug)
// ===================================================================================================

// Endpoint de utilidad para verificar y analizar tokens JWT manualmente
// √ötil para debugging, desarrollo y auditor√≠a de tokens
app.post('/api/verify-token', (req, res) => {
  console.log('\nüîç ================================================');
  console.log('üîç VERIFICACI√ìN MANUAL DE TOKEN (DEBUG)');
  console.log('üîç ================================================');
  
  const { token } = req.body;
  
  console.log('üì• Token recibido para verificaci√≥n:');
  console.log('   ‚Ä¢ Token presente:', !!token);
  if (token) {
    console.log('   ‚Ä¢ Longitud:', token.length);
    console.log('   ‚Ä¢ Estructura (partes):', token.split('.').length);
  }
  
  if (!token) {
    console.log('‚ùå Error: Token no proporcionado');
    return res.status(400).json({ 
      error: 'Token requerido para verificaci√≥n',
      usage: 'Env√≠a { "token": "tu-jwt-token" } en el body'
    });
  }
  
  try {
    console.log('üîç PASO 1: Decodificaci√≥n sin verificaci√≥n...');
    // Decodificar sin verificar firma (para inspecci√≥n)
    const decoded = jwt.decode(token, { complete: true });
    
    if (decoded) {
      console.log('‚úÖ Token decodificado exitosamente:');
      console.log('   üìã Header:', JSON.stringify(decoded.header, null, 2));
      console.log('   üì¶ Payload:', JSON.stringify(decoded.payload, null, 2));
      console.log('   üîê Signature presente:', !!decoded.signature);
    }
    
    console.log('üîç PASO 2: Verificaci√≥n con clave secreta...');
    // Verificar firma con clave secreta
    const verified = jwt.verify(token, JWT_SECRET) as JwtPayload;
    
    console.log('‚úÖ TOKEN COMPLETAMENTE V√ÅLIDO:');
    console.log('   ‚úÖ Estructura correcta');
    console.log('   ‚úÖ Firma v√°lida');
    console.log('   ‚úÖ No expirado');
    console.log('   ‚úÖ Algoritmo correcto');
    
    // An√°lisis temporal detallado
    const now = Math.floor(Date.now() / 1000);
    const timeLeft = verified.exp! - now;
    const tokenAge = now - verified.iat!;
    
    console.log('üìä An√°lisis temporal:');
    console.log('   ‚è∞ Edad del token:', tokenAge, 'segundos');
    console.log('   ‚è±Ô∏è Tiempo restante:', timeLeft, 'segundos');
    console.log('   üìà Porcentaje de vida usada:', Math.round((tokenAge / 900) * 100), '%');
    
    // Respuesta completa con an√°lisis
    res.json({
      valid: true,
      message: 'Token verificado exitosamente',
      tokenAnalysis: {
        structure: 'V√°lida (3 partes)',
        signature: 'V√°lida',
        algorithm: decoded?.header?.alg || 'Unknown',
        expiration: 'No expirado'
      },
      decoded: verified,
      header: decoded?.header,
      payload: decoded?.payload,
      temporal: {
        issuedAt: new Date(verified.iat! * 1000).toISOString(),
        expiresAt: new Date(verified.exp! * 1000).toISOString(),
        ageInSeconds: tokenAge,
        timeLeftInSeconds: timeLeft,
        percentageUsed: Math.round((tokenAge / 900) * 100)
      },
      security: {
        signatureVerified: true,
        algorithmSecure: decoded?.header?.alg === 'HS256',
        notExpired: timeLeft > 0
      }
    });
    
  } catch (error) {
    console.log('‚ùå ERROR EN VERIFICACI√ìN:');
    console.log('   ‚Ä¢ Tipo de error:', error instanceof Error ? error.constructor.name : 'Unknown');
    console.log('   ‚Ä¢ Mensaje:', error instanceof Error ? error.message : 'Error desconocido');
    
    // Intentar decodificar sin verificar para dar m√°s informaci√≥n
    try {
      const decoded = jwt.decode(token, { complete: true });
      console.log('‚ÑπÔ∏è Informaci√≥n del token (sin verificar firma):');
      console.log('   üìã Header:', decoded?.header);
      console.log('   üì¶ Payload:', decoded?.payload);
      
      res.status(401).json({
        valid: false,
        error: error instanceof Error ? error.message : 'Token inv√°lido',
        tokenStructure: decoded ? 'V√°lida' : 'Inv√°lida',
        possibleCauses: [
          'Token expirado',
          'Firma inv√°lida (token manipulado)',
          'Algoritmo incorrecto',
          'Clave secreta incorrecta',
          'Token malformado'
        ],
        decoded: decoded?.payload || null,
        header: decoded?.header || null,
        hint: 'Obt√©n un nuevo token atrav√©s del login'
      });
    } catch {
      console.log('üí• Token completamente malformado');
      res.status(400).json({
        valid: false,
        error: 'Token completamente malformado',
        structure: 'Inv√°lida',
        hint: 'Verifica que el token tenga el formato correcto: header.payload.signature'
      });
    }
  }
});

// ===================================================================================================
// üìä RUTA: GET /api/status - Estado del servidor y estad√≠sticas
// ===================================================================================================

// Endpoint informativo que muestra el estado del servidor y estad√≠sticas de JWT
app.get('/api/status', (req, res) => {
  console.log('\nüìä ================================================');
  console.log('üìä CONSULTA DE ESTADO DEL SERVIDOR');
  console.log('üìä ================================================');
  
  console.log('üìà Recopilando estad√≠sticas del servidor:');
  console.log('   üîÑ Refresh tokens activos:', refreshTokens.length);
  console.log('   üë• Usuarios registrados:', users.length);
  console.log('   üïê Uptime del proceso:', process.uptime(), 'segundos');
  console.log('   üíæ Uso de memoria:', Math.round(process.memoryUsage().heapUsed / 1024 / 1024), 'MB');
  
  // An√°lisis de tokens activos
  let tokenStats = {
    total: refreshTokens.length,
    oldestToken: null as Date | null,
    newestToken: null as Date | null
  };
  
  // Analizar tokens para estad√≠sticas temporales
  if (refreshTokens.length > 0) {
    console.log('üîç Analizando tokens activos...');
    try {
      const tokenDates = refreshTokens.map(token => {
        const decoded = jwt.decode(token) as any;
        return new Date(decoded.iat * 1000);
      }).sort();
      
      tokenStats.oldestToken = tokenDates[0];
      tokenStats.newestToken = tokenDates[tokenDates.length - 1];
      
      console.log('   üìÖ Token m√°s antiguo:', tokenStats.oldestToken?.toISOString());
      console.log('   üìÖ Token m√°s reciente:', tokenStats.newestToken?.toISOString());
    } catch (error) {
      console.log('   ‚ö†Ô∏è Error analizando tokens:', error);
    }
  }
  
  // Respuesta completa con estado del servidor
  res.json({
    server: 'JWT Authentication Server',
    status: 'running',
    version: '1.0.0',
    timestamp: new Date().toISOString(),
    
    // Estad√≠sticas de JWT
    jwtStatistics: {
      activeRefreshTokens: refreshTokens.length,
      registeredUsers: users.length,
      tokenStats
    },
    
    // Configuraci√≥n JWT
    jwtConfiguration: {
      accessTokenExpiry: '15 minutes',
      refreshTokenExpiry: '7 days',
      algorithm: 'HS256',
      dualTokenStrategy: true,
      serverSideRevocation: true
    },
    
    // Endpoints disponibles
    endpoints: {
      authentication: [
        'POST /api/login',
        'POST /api/logout',
        'POST /api/refresh'
      ],
      protected: [
        'GET /api/profile',
        'GET /api/secret-data'
      ],
      utility: [
        'POST /api/verify-token',
        'GET /api/status'
      ]
    },
    
    // Informaci√≥n del sistema
    system: {
      nodeVersion: process.version,
      platform: process.platform,
      uptime: Math.round(process.uptime()),
      memoryUsage: {
        heapUsed: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
        heapTotal: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
        external: Math.round(process.memoryUsage().external / 1024 / 1024)
      }
    },
    
    // Caracter√≠sticas de seguridad
    security: {
      cors: 'Configurado para frontend espec√≠fico',
      tokenStorage: 'En memoria (usar Redis en producci√≥n)',
      secretManagement: 'Hardcoded (usar variables de entorno en producci√≥n)',
      passwordHashing: 'No implementado (usar bcrypt en producci√≥n)',
      httpsRequired: 'Recomendado para producci√≥n'
    }
  });
});

// ===================================================================================================
// üöÄ INICIALIZACI√ìN DEL SERVIDOR
// ===================================================================================================

// Iniciar el servidor HTTP y comenzar a escuchar peticiones
app.listen(PORT, () => {
  console.log('\nüöÄ ================================================');
  console.log('üöÄ JWT AUTHENTICATION SERVER INICIADO');
  console.log('üöÄ ================================================');
  console.log(`üì± Puerto: ${PORT}`);
  console.log(`üåê URL base: http://localhost:${PORT}`);
  console.log('üîê JWT authentication configured');
  console.log('üîÑ Refresh token system enabled');
  console.log('üí° Endpoints disponibles en http://localhost:3000/api/');
  console.log('\nüìã CONFIGURACI√ìN DEL SERVIDOR:');
  console.log('   ‚úÖ Express.js configurado');
  console.log('   ‚úÖ CORS habilitado para frontend');
  console.log('   ‚úÖ Middleware JSON configurado');
  console.log('   ‚úÖ Autenticaci√≥n JWT implementada');
  console.log('   ‚úÖ Rutas protegidas configuradas');
  console.log('   ‚úÖ Sistema de refresh tokens activo');
  console.log('\nüîí CARACTER√çSTICAS DE SEGURIDAD:');
  console.log('   üõ°Ô∏è Estrategia de doble token (access + refresh)');
  console.log('   üõ°Ô∏è Verificaci√≥n de firma digital');
  console.log('   üõ°Ô∏è Expiraci√≥n autom√°tica de tokens');
  console.log('   üõ°Ô∏è Revocaci√≥n server-side de refresh tokens');
  console.log('   üõ°Ô∏è Control de acceso basado en roles (RBAC)');
  console.log('\n‚ö†Ô∏è NOTAS PARA PRODUCCI√ìN:');
  console.log('   üîß Usar variables de entorno para secretos');
  console.log('   üîß Implementar Redis para storage de tokens');
  console.log('   üîß Usar bcrypt para hashing de contrase√±as');
  console.log('   üîß Configurar HTTPS obligatorio');
  console.log('   üîß Implementar rate limiting');
  console.log('   üîß Agregar logging y monitoreo');
  console.log('\nüéØ SERVIDOR LISTO PARA RECIBIR PETICIONES');
  console.log('üéØ ================================================\n');
});